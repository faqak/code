## 1761E

考虑一些特殊答案取值对应的局面，看看除了这些是不是只剩下一些 trivial 的东西（**套路**）。

- $ans = 0$：原图连通。
- $ans = 1$：
  - 存在孤立点（操作其本身）
  - 存在一个非团的连通块（操作连通块内 $deg$ 最小的点）
- $ans = 2$：所有连通块均为团，但有 $3$ 个及以上连通块（随便操作一个点，此时被归纳到 $ans = 1$ 的情况）

剩下的情况只有图恰好由两个团组成，此时 $ans$ 为两团点数的最小值，因为必须消完一整个团才能使原图联通。

## 1753D

想象一下这个过程：想要腾出 A，我们可以旋转床 B，但旋转过去的要求是腾出 C，然后又考虑腾出 C。

这样根据限制，依次满足一些点，前一个满足了后一个才能满足的问题可以用图论刻画（**套路**）。

具体来说，我们可以把“腾出了 A 就能腾出 C”这样的关系建一条 $A \to C$，把每个初始空着的格子加入队列里，跑 dijkstra 即可得到每个格子想要腾出所需要的最小步数。

建图的时间复杂度保证依赖于结论“每张床只会被移动一次”，原因：移动两次一定完全离开原来的位置，说明在移动它之前，它将要新占据的格子已经被完全腾空，此时已经造出了 $1 × 2$ 的空地，不需要再移动该床了。

这样，我们就可以直接建图了，边数仅 $O(nm)$。

但是我们要腾出 $1 × 2$ 的空地，所以上述方法是有问题的，因为有可能在移动一张床时又优化了 A，又优化了 B，怎么搞？

这个时候，就需要观察这张图的性质，我们发现，连边时只会在 $(i + j)$ 同奇偶的点之间连边，也就是说，这张图可以拆成两张互不影响的子图，而且两个紧挨的格子分属两边。

因此，我们直接把两者的 $\text{dis}$ 加起来就一定是对的了。

## 1750E

我们肯定首先需要对每个子串用可以维护的式子表示贡献。

注意到已经匹配的括号对于答案无贡献，那么我们可以直接把串中已经匹配的括号删除，容易知道这样会把串变为 `))...)((...(` 的形式（**套路**）。

于是设剩下有 $L$ 个左括号，$R$ 个右括号，观察得出贡献为 $\max(L, R)$，原因显然。

考虑这个东西有一个缩括号的过程，不好维护，我们用原串中的信息来表示，为 $\max(L, R) - X$（$X$ 为已经匹配的括号对数）。

拆开维护，$\sum X$ 可以拆贡献，因为一对括号在子串中匹配仅当在原串中匹配（**套路**）。

对于 $\sum \max(L, R)$，$\max(L, R) = (L + R + |R-L|) \div 2$（**套路**）。

$\sum L$ 和 $\sum R$ 都可以随便拆贡献，而 $\sum |R-L|$ 的实质是给 `)` 赋 $1$，给 `(` 赋 $-1$，然后所有区间和的绝对值之和，可以把前缀和搞出来，排完序就是 $\sum_{i=1}^n\sum_{j=i}^n s_j - s_i$，直接算。

## 1749E

不难发现对于一个合法的最终局面，一定存在一条从第一列到最后一列的斜连通路。

因此我们把已经激活的点权设为 $0$，未激活的点权设为 $1$，跑多源 $01$ 点权 bfs 即可。

## 1738F

$s_c \leq n_c^2$ 即 $\bar{\text{deg}_c} \leq n_c$。

遇到这种很难看的条件，我们可以考虑合理强化原问题（**套路**）。

本题可以强化为 $\max{\text{deg}_c} \leq n_c$，这样，我们选择一个连通块全部染色即可。

但是 bfs 一遍的次数达到了 $O(n + m)$，不能通过本题，我们可以考虑每次选择一个特殊点并更新决策（**套路**）。

比如，我们每次选择度数最大的点：

1. 如果它的一个邻居已经被染色，那么我们和这个邻居染相同的颜色即可，因为该颜色连通块一定有度数更大的，加入这些点只会增大 $n_c$。
2. 否则，我们把它和它的邻居染为一种颜色，显然也合法。

每个点只会被扫到一次，一共 $n - C$ 次访问，可以切。