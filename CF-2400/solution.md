## 1761E

考虑一些特殊答案取值对应的局面，看看除了这些是不是只剩下一些 trivial 的东西（**套路**）。

- $ans = 0$：原图连通。
- $ans = 1$：
  - 存在孤立点（操作其本身）
  - 存在一个非团的连通块（操作连通块内 $deg$ 最小的点）
- $ans = 2$：所有连通块均为团，但有 $3$ 个及以上连通块（随便操作一个点，此时被归纳到 $ans = 1$ 的情况）

剩下的情况只有图恰好由两个团组成，此时 $ans$ 为两团点数的最小值，因为必须消完一整个团才能使原图联通。

## 1753D

想象一下这个过程：想要腾出 A，我们可以旋转床 B，但旋转过去的要求是腾出 C，然后又考虑腾出 C。

这样根据限制，依次满足一些点，前一个满足了后一个才能满足的问题可以用图论刻画（**套路**）。

具体来说，我们可以把“腾出了 A 就能腾出 C”这样的关系建一条 $A \to C$，把每个初始空着的格子加入队列里，跑 dijkstra 即可得到每个格子想要腾出所需要的最小步数。

建图的时间复杂度保证依赖于结论“每张床只会被移动一次”，原因：移动两次一定完全离开原来的位置，说明在移动它之前，它将要新占据的格子已经被完全腾空，此时已经造出了 $1 × 2$ 的空地，不需要再移动该床了。

这样，我们就可以直接建图了，边数仅 $O(nm)$。

但是我们要腾出 $1 × 2$ 的空地，所以上述方法是有问题的，因为有可能在移动一张床时又优化了 A，又优化了 B，怎么搞？

这个时候，就需要观察这张图的性质，我们发现，连边时只会在 $(i + j)$ 同奇偶的点之间连边，也就是说，这张图可以拆成两张互不影响的子图，而且两个紧挨的格子分属两边。

因此，我们直接把两者的 $\text{dis}$ 加起来就一定是对的了。

## 1750E

我们肯定首先需要对每个子串用可以维护的式子表示贡献。

注意到已经匹配的括号对于答案无贡献，那么我们可以直接把串中已经匹配的括号删除，容易知道这样会把串变为 `))...)((...(` 的形式（**套路**）。

于是设剩下有 $L$ 个左括号，$R$ 个右括号，观察得出贡献为 $\max(L, R)$，原因显然。

考虑这个东西有一个缩括号的过程，不好维护，我们用原串中的信息来表示，为 $\max(L, R) - X$（$X$ 为已经匹配的括号对数）。

拆开维护，$\sum X$ 可以拆贡献，因为一对括号在子串中匹配仅当在原串中匹配（**套路**）。

对于 $\sum \max(L, R)$，$\max(L, R) = (L + R + |R-L|) \div 2$（**套路**）。

$\sum L$ 和 $\sum R$ 都可以随便拆贡献，而 $\sum |R-L|$ 的实质是给 `)` 赋 $1$，给 `(` 赋 $-1$，然后所有区间和的绝对值之和，可以把前缀和搞出来，排完序就是 $\sum_{i=1}^n\sum_{j=i}^n s_j - s_i$，直接算。

## 1749E

不难发现对于一个合法的最终局面，一定存在一条从第一列到最后一列的斜连通路。

因此我们把已经激活的点权设为 $0$，未激活的点权设为 $1$，跑多源 $01$ 点权 bfs 即可。

## 1738F

$s_c \leq n_c^2$ 即 $\bar{\text{deg}_c} \leq n_c$。

遇到这种很难看的条件，我们可以考虑合理强化原问题（**套路**）。

本题可以强化为 $\max{\text{deg}_c} \leq n_c$，这样，我们选择一个连通块全部染色即可。

但是 bfs 一遍的次数达到了 $O(n + m)$，不能通过本题，我们可以考虑每次选择一个特殊点并更新决策（**套路**）。

比如，我们每次选择度数最大的点：

1. 如果它的一个邻居已经被染色，那么我们和这个邻居染相同的颜色即可，因为该颜色连通块一定有度数更大的，加入这些点只会增大 $n_c$。
2. 否则，我们把它和它的邻居染为一种颜色，显然也合法。

每个点只会被扫到一次，一共 $n - C$ 次访问，可以通过。

## 1735E

首先，不妨设 $p_1 < p_2$，否则我们可以把它关于 $-\infty$ 对称。

因为我们只关心这些点的相对距离，所以我们可以考虑 $D = |p_1 - p_2|$ 的取值：

若 $d_1$ 中的 $1$ 和 $d_2$ 的 $i$ 配对，显而易见的是 $D = |d_{1, 1} - d_{2, i}|$ 或 $D = d_{1, 1} + d_{2, i}$。

因此，$D$ 的取值仅有 $2n$ 种，我们可以考虑枚举每个取值去 check。

check 的方法：

1. 找到所有 $d$ 中的最大值 $v$。
2. 如果 $v \leq D$，那么以后的所有点（包括这个）都在 $p_1, p_2$ 之间，排一遍序即可匹配。
3. 否则，说明这个点在 $p_2$ 的右侧或 $p_1$ 的左侧，所以和它匹配的值应该为 $v - D$。

总时间复杂度 $O(n^2\log n)$。

注意在使用 multiset 维护上述操作时，判断是否被删除应当使用 `find` 函数，而不应使用 `count` 函数。

原因：`find` 时间复杂度严格 $\log$，而 `count` 的时间复杂度为 $\log + k$，其中 $k$ 为返回值。

## 1718C

题目很长，题意是让你求对于所有 $(s, k)$，求最大的 $\sum_{i=0}^{n - 1}a_{{s + ki}\bmod n}$。

考虑化一下这个式子，使得一个值只被贡献一次： $\gcd(k, n)\sum_{i=0}^{\text{lcm}(k, n) / k - 1} a_{{s + ki}\bmod n}$。

对于 $k' | k$，不难发现 $k$ 严格优于 $k'$（因为 $k$ 的循环节更短，可以选择 $k'$ 中最大的几个，但 $k'$ 仍要被较小的几个占据）（**套路**）。

那么我们实际上只用考虑所有 $k = \dfrac{n}{p}$，其中 $p$ 是 $n$ 的一个质因数，这样的 $k$ 只有 $\log$ 个。

修改的时候直接暴力改即可，反正对于每个 $k$ 只有一个起始点需要改（所有起始点用到的点在同一个 $k$ 里不交）。

## 1715E

这种有特殊边，并且限制特殊边经过次数的，可以使用分层图刻画（**套路**）。

但在本题，暴力建出分层图，边数会达到 $O(k(n^2 + m))$，无法实现。

不难发现，分层图是分层转移的，而我们的瓶颈在于两层连接的地方，我们可以考虑优化。

这个 $(u - v)^2$ 的边权虽然不能用图论转化，但是可以 dp，总时间复杂度 $O(k(n + m)\log m)$。

## 1713E

很显然这种字典序贪心是从前往后贪，我们考虑 $a(x, y)$ 和 $a(y, x)$（$x < y$），如果 $a(x, y) > a(y, x)$，那么 $a(x, y)$ 将被交换。

我们考虑设 $C_i$ 表示第 $i$ 行有没有被交换，那么上述条件即 $C_x \ \text{xor}  \ C_y = 1$，否则为 $C_x \ \text{xor} \ C_y = 0$。

我们用一个并查集维护，如果某一个时刻矛盾了，不取即可，因为这样前面的才能更大。